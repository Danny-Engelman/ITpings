/** @license
 * The ITpings Dashboard is minified because I do not want it to go wild without needed refactoring
 * Currently it only works with the default ITpings_configuration.php,
 * many references (eg: '_pingid' are hardcoded in the Dashboard sourcecode
 *
 * The MIT license still applies to this code, feel free to edit the .HTML file anyway you want
 *
 * Be sure to check the Github Repo often for the (future) refactored JS file
 * */
!function(e, t) {
    let a, i = (e, t, a = "", i = "", r = "", l = "", n = "", s = "", o = "", d = "") => {
        console.log(`%cWC:${e}:`, "background:" + t, a, i, r, l, n, s, o, d);
    };
    a = 1e3, console.log("Heartbeat:", a);
    let r = "ttn_node_365csi_nl_001,ttn_node_365csi_nl_002".split`,`;
    let l = new class {
        constructor(e) {
            this.devices = {}, this.colors = "#e6194b,#0082c8,#f58231,#911eb4,#46f0f0,#f032e6,#d2f53c,#fabebe,#008080,#e6beff,#aa6e28,#fffac8,#800000,#aaffc3,#808000,#ffd8b1,#000080,#808080".split(","), 
            this.styles = [ ...t.styleSheets ].filter(t => t.title === e)[0];
        }
        getColor(e) {
            let t, a = this, i = a.devices;
            if (i.hasOwnProperty(e)) t = i[e]; else {
                t = a.colors.shift(), i[e] = t;
                let r = "TD[data-dev_id='" + e + "'] {border-bottom: 3px solid " + t + ";}";
                a.styles.insertRule(r, 0);
            }
            return t;
        }
    }("DynamicDeviceColors");
    r.map(e => l.getColor(e));
    let n = e => t.createElement(e), s = e => {
        let t = n("DIV");
        return e && (t.innerHTML = e), t;
    }, o = (e, t) => e.appendChild(t), d = (e, t) => e.getAttribute(t), c = (e, t, a) => e.setAttribute(t, a), h = (e, t) => e.classList.add(t), u = e => Object.keys(e), m = e => {
        let t = location.href.split`/`;
        return t.pop(), t.push("ITpings_connector.php?query=" + e), t = t.join`/`;
    }, f = "query", p = "pulse";
    let g = e.i = new class {
        _log(e, t, a, r, l, n, s, o) {
            i("IQM", "lightcoral", e, t, a, r, l, n, s, o);
        }
        constructor(t) {
            let i = this;
            i[p] = new Map(), a && (i.interval = e.setInterval(() => {
                i.doPulse();
            }, a));
        }
        register(e) {
            let t, a, i = d(e, p);
            i ? (t = (i = i.split`:`)[0], a = i[1]) : (t = d(e, f), a = e.idfield || "_pingid"), 
            console.log("register", t, a);
            let r = this[p];
            r.has(t) || r.set(t, new Map());
            let l = r.get(t);
            l.has(a) || l.set(a, new Set()), l.get(a).add(e), this._log("register for doPulse", t, a, r);
        }
        doPulse() {
            let e = this;
            fetch(m("IDs")).then(e => e.json()).then(t => {
                e._log("Get recent ID valuesfrom DB, sent Pulse to CustomElements (they decide to fetch New data or not)");
                for (let a in t.maxids) {
                    let i = t.maxids[a], r = u(i)[0], l = i[r], n = e[p].get(a);
                    if (n) {
                        let t = n.get(r);
                        t ? t.forEach(e => e.doPulse(l, r)) : e._log("No fieldSet", a, r, l, n, t);
                    }
                }
            });
        }
    }();
    !function(a = "itpings-table") {
        let r = (e, t, r, l, n, s, o, d) => i(a, "lightgreen", e, t, r, l, n, s, o, d);
        e.customElements.define(a, class extends HTMLElement {
            static get observedAttributes() {
                return [ f, "pulse" ];
            }
            constructor() {
                super(), this.maxid = 1;
            }
            addRow(e, t = "h") {
                let a = this, i = "h" !== t, r = (i ? a.TBODY : a.THEAD).insertRow(t);
                u(e).map(l => {
                    if (!a.hiddenfields.has(l)) {
                        let n = r.insertCell(), s = "h" === t ? l : e[l];
                        if (c(r, "data-" + l, s), ((e, t) => u(t).map(a => c(e, a, t[a])))(n, {
                            ["data-" + l]: s,
                            "data-column": l
                        }), h(n, "fadeOutCell"), i && "LastSeen" === l) {
                            let e = moment(s), t = moment();
                            s = e.diff(t, "minutes");
                        }
                        l === a.idfield && Number(s) > a.maxid && (a.maxid = Number(s)), n.innerHTML = s;
                    }
                });
            }
            fetchData(e) {
                let t = this, a = t.addRow.bind(t);
                t.idle && (t.idle = !1, r("filter:", e), fetch(t.uri + e).then(e => e.json()).then(e => {
                    let i = e.result;
                    if (i) {
                        if (t.idfield) i.length && (t.TBODY = ((e, t, a) => e.insertBefore(t, a))(t.TABLE, o(t.TABLE, (() => n("TBODY"))()), t.TBODY), 
                        h(t.TBODY, "newPing"), i.map(e => a(e, 0))); else {
                            let e = i[0];
                            a(e), t.idfield = u(e)[0], console.log("reg", t.idfield, t), i.map(a), o(t, t.TABLEWRAPPER), 
                            g.register(t);
                        }
                        t.idle = !0;
                    } else {
                        let e = t[f], a = s(`<b><a href=?query='${e}'>${e}</a></b>` + " is not a valid ITpings result source");
                        h(a, "itpings-table-error"), o(t, a);
                    }
                }).catch(e => {
                    console.error(e), t.innerHTML = e + "<h2>Empty Database, check your HTTP Integration setting and reload page</h2>";
                }));
            }
            doPulse(e, t) {
                let a = this, i = a.maxid, l = a.idfield;
                e > i && (r("doPulse Table", a.query, l, t, i, e), a.fetchData("&filter=" + l + " gt " + i));
            }
            attributeChangedCallback(e, t, a) {
                let i = this;
                i[e] = a, e === f ? (i.uri = m(a), i.filter = "", i.idle = !0) : "pulse" === e && (r("do pulse from", e, t, a, i.query), 
                i.isPulsed = !0, i.doPulse());
            }
            connectedCallback() {
                let e = this;
                e.TABLEWRAPPER = s(), e.TABLE = o((() => t.createDocumentFragment())(), (() => n("TABLE"))());
                let a = t => o(e.TABLE, n(t));
                e.THEAD = a("THEAD"), e.TBODY = a("TBODY");
                let i = o(e.TABLEWRAPPER, s());
                i.innerHTML = e.title, h(i, "table-title"), o(e.TABLEWRAPPER, e.TABLE), h(e.TABLEWRAPPER, "table-wrapper"), 
                e.hiddenfields = new Set([ "timestamp", "created" ]), e.fetchData("");
            }
        });
    }(), function(t = "itpings-chart") {
        let a = (e, a, r, l, n, s, o, d) => i(t, "lightblue", e, a, r, l, n, s, o, d), r = {
            m5: {
                interval: 5,
                unit: "MINUTE",
                xformat: "H:mm"
            },
            m03: {
                interval: 30,
                unit: "MINUTE",
                xformat: "H:mm"
            },
            H1: {
                interval: 1,
                unit: "HOUR",
                xformat: "H:mm"
            },
            H2: {
                interval: 2,
                unit: "HOUR",
                xformat: "H:mm"
            },
            H6: {
                interval: 6,
                unit: "HOUR",
                xformat: "H:mm"
            },
            D1: {
                interval: 1,
                unit: "DAY",
                xformat: "D MMM H:mm"
            },
            D2: {
                interval: 2,
                unit: "DAY",
                xformat: "D MMM H:mm"
            },
            W2: {
                interval: 2,
                unit: "WEEK",
                xformat: "D MMM H:mm"
            },
            M1: {
                interval: 1,
                unit: "MONTH",
                xformat: "D MMM"
            },
            M6: {
                interval: 6,
                unit: "MONTH",
                xformat: "D MMM"
            },
            Y1: {
                interval: 1,
                unit: "YEAR",
                xformat: "D MMM"
            }
        };
        e.customElements.define(t, class extends HTMLElement {
            static get observedAttributes() {
                let e = [ "sensorname", "interval" ];
                return a("CustomElement observedAttributes", e), e;
            }
            get chartid() {
                return d(this, "chartid");
            }
            get sensorname() {
                return d(this, "sensorname");
            }
            set sensorname(e) {
                c(this, "sensorname", e);
            }
            get interval() {
                return d(this, "interval");
            }
            set interval(e) {
                a("(setter) ►►►", "interval", ":", e);
                let t = this.INTERVALS.querySelector("[id='" + e + "']");
                localStorage.setItem(this.chartid + "_interval", e), [ ...this.INTERVALS.children ].map(e => e.classList[e === t ? "add" : "remove"]("selectedInterval")), 
                c(this, "interval", e), this.prepareChart(!1);
            }
            prepareChart(e = !1) {
                let t = this, i = t.sensorname;
                e && (t.interval = e);
                let l = t.interval, n = r[l];
                n || (n = r.H6), a("prepareChart _interval", l, n, e ? "localStorage" : ""), t._interval = n, 
                t.ChartJS = {
                    id: i,
                    uri: m("SensorValues&sensorname=" + i + "&orderby=created&interval=" + n.interval + "&intervalunit=" + n.unit + "&limit=none&maxrows=225"),
                    chartdata: {
                        labels: [],
                        datasets: [],
                        sensorids: []
                    }
                }, t.chart && t.chart.destroy(), t.chart = new Chart(t.CANVAS, {
                    type: "line",
                    data: [],
                    options: {
                        maintainAspectRatio: !1,
                        title: {
                            display: !0,
                            text: i
                        },
                        showLines: !0,
                        elements: {
                            line: {
                                tension: 0
                            }
                        }
                    }
                }), t.displayChart(t.ChartJS.uri);
            }
            doPulse(e) {
                let t = this, i = ~~t._pingid;
                if (i) {
                    if (i < e) {
                        a("doPulse ChartJS _pingid:", i, "new:", e);
                        let r = t.chart, l = m("SensorValues&sensorname=" + t.ChartJS.id + "&orderby=_pingid%20ASC&limit=none&filter=_pingid%20gt%20" + i);
                        fetch(l).then(e => e.json()).then(e => {
                            let i = t.ChartJS.chartdata, l = e.result;
                            a("updateChart", l.length, "rows from:", e.sql), l.map(e => {
                                let a = e._sensorid, r = e.sensorvalue, l = i.sensorids.indexOf(a), n = e.created;
                                n = moment(n).format(t._interval.xformat), t._pingid = e._pingid, i.datasets[l].data.push({
                                    x: n,
                                    y: r
                                }), i.labels.includes(n) || i.labels.push(n);
                            }), r.update();
                        });
                    }
                } else a("►►► No _pingid on ChartJS yet (not drawn yet) ◄◄◄");
            }
            updateChart(e) {}
            displayChart(e) {
                let t = this, i = t.chart;
                fetch(e).then(e => e.json()).then(e => {
                    let r = t.ChartJS.chartdata, n = e.result, s = "";
                    a("displayChart", n.length, "rows"), r = n.reduce(function(e, a, i) {
                        t._pingid = a._pingid;
                        let r = a.dev_id, n = a._sensorid, o = a.sensorvalue, d = e.sensorids.indexOf(n), c = a.created;
                        if (c = moment(c).format(t._interval.xformat), s = a.sensorname, d < 0) {
                            d = e.datasets.length;
                            let t = l.getColor(r);
                            e.datasets.push({
                                label: (e => [ "", "attic", "desk" ][Number(e.split`_`.reverse()[0])])(r),
                                fill: !1,
                                backgroundColor: t,
                                borderColor: t,
                                data: []
                            }), e.sensorids.push(n);
                        }
                        return e.datasets[d].data.push({
                            x: c,
                            y: o
                        }), e.labels.includes(c) || e.labels.push(c), e;
                    }, r), i.data.labels = r.labels, i.data.datasets = r.datasets, i.update();
                });
            }
            constructor() {
                super();
            }
            attributeChangedCallback(e, t, i) {
                let r = this;
                switch (a("attributeChanged:", e, " oldValue:", t, " newValue:", i, " isConnected:", r.isConnected ? "true" : "false"), 
                e) {
                  case "interval":
                    r.isConnected;
                }
            }
            connectedCallback() {
                let e = this;
                a("CustomElement connectedCallback");
                let t = s(), i = e => o(t, n(e));
                (e => h(t, e))("chart"), c(t, "style", "position:relative;height:inherit;"), e.CANVAS = i("CANVAS");
                let l = e.INTERVALS = i("DIV"), d = t => o(l, (t => {
                    let a = s((e => [ ...e ].reverse().join``)(t));
                    return c(a, "id", t), a.addEventListener("click", () => e.interval = t), a;
                })(t));
                u(r).map(e => d(e)), h(l, "chart_interval"), o(e, t);
                let m = e.chartid, f = !1;
                m ? (f = localStorage.getItem(m + "_interval"), a("localStorage:", m, f), e.interval = f || e.interval) : console.error("no id on chart", e), 
                g.register(e);
            }
            disconnectedCallback() {
                a("disconnected", this.isConnected ? "connected" : "NOT connected");
            }
        });
    }();
}(window, document.currentScript.ownerDocument);