/** @license MIT
 * This Dashboard uses hardcoded Databases references
 * If you make changes in the Database Schema, be sure to check those new names in this Dashboard source code
 * */
!function(e, t) {
    let s = (e, t, s = "", i = "", n = "", r = "", l = "", a = "", o = "", d = "") => {
        console.log(`%cWC:${e}:`, "background:" + t || "lightcoral", s, i, n, r, l, a, o, d);
    }, i = " QueryManager can't register", n = "register for doPulse", r = e => void 0 !== e, l = e => e.split`,`, a = e => e.shift(), o = e => t.createElement(e), d = e => {
        let t = o("DIV");
        return e && (t.innerHTML = e), t;
    }, c = (e, t) => {
        let s = d(e);
        return s.classList.add(t), s;
    }, u = (e, t) => e.innerHTML = t, h = (e, t) => e.appendChild(t), m = (e, t) => e.getAttribute(t), g = (e, t, s) => e.setAttribute(t, s), f = (e, t) => e.classList.add(t), T = e => Object.keys(e), p = e => [ ...t.styleSheets ].filter(t => t.title === e)[0], b = (e, t) => e.insertRule(t, 0), E = (e, t) => r(t) ? moment(e).format(t) : moment(e), C = e => new Promise((t, i) => {
        fetch(e).then(e => e.json()).then(i => {
            s("Fetched", "orange", e, i.sql), t(i);
        });
    }), A = e => {
        let t = location.href.split`/`;
        return t.pop(), t.push("ITpings_connector.php?query=" + e), t = t.join`/`;
    };
    let D = new class {
        constructor(e) {
            this.STYLE = p(e), this.deviceColor = new Map(), this.colors = l("#e6194b,#0082c8,#f58231,#911eb4,#46f0f0,#f032e6,#d2f53c,#fabebe,#008080,#e6beff,#aa6e28,#fffac8,#800000,#aaffc3,#808000,#ffd8b1,#000080,#808080,#ffe119");
        }
        getColor(e) {
            let t, s = this, i = s.deviceColor;
            return i.has(e) ? t = i.get(e) : (t = a(s.colors), i.set(e, t), b(s.STYLE, `TD[data-dev_id='${e}'] {border-bottom: 3px solid ${t};}`)), 
            t;
        }
    }("DynamicDeviceColors"), L = "PingID", v = "IDs", M = "query", H = "pulse";
    class y {
        static _log(e, t, i, n, r, l, a, o) {
            s("IQM", "lightcoral", e, t, i, n, r, l, a, o);
        }
        constructor() {
            this.maxid = 0, this[H] = new Map(), this.doPulse(L);
        }
        register(e) {
            let t, s, r = m(e, H);
            r ? (t = (r = r.split`:`)[0], s = r[1]) : (t = e.query || m(e, M), s = e.idfield || "_pingid"), 
            t || console.error(i, e);
            let l = this[H];
            l.has(t) || l.set(t, new Map());
            let a = l.get(t);
            a.has(s) || a.set(s, new Set()), a.get(s).add(e), y._log(n, t, s);
        }
        doPulse(t) {
            let s = this, i = (t, i) => e.setTimeout(() => s.doPulse(t), i || S);
            C(A(t)).then(e => {
                t === L ? e > s.maxid ? (s.maxid = e, i(v, 1)) : i(L) : (y._log(S, "Got recent ID values from Database", e), 
                T(e.maxids).forEach(t => {
                    let i = e.maxids[t], n = T(i)[0], r = i[n], l = s[H].get(t);
                    if (l) {
                        let e = l.get(n);
                        e ? e.forEach(e => e.doPulse(r, n)) : y._log("No fieldSet", t, n, r, l, e);
                    }
                }), i(L));
            });
        }
    }
    let S, _ = e.i = new y(), w = e => {
        s("Heartbeat:", "orange", S = e), r(_) && _.doPulse(L);
    };
    w(1e3), e.onfocus = (() => w(1e3)), e.onblur = (() => w(18e5)), function(t = "itpings-table") {
        let i, n = (e, n, r, l, a, o, d, c) => s(t + ":" + i, "lightgreen", e, n, r, l, a, o, d, c);
        e.customElements.define(t, class extends HTMLElement {
            static get observedAttributes() {
                let e = [ M ];
                return n("CustomElement observedAttributes:", e), e;
            }
            get title() {
                return m(this, "title");
            }
            set title(e) {
                g(this, "title", e);
            }
            constructor() {
                super(), i = this.getAttribute(M), n("CustomElement constructor", this), this.maxid = 1;
            }
            prepareTable() {
                let e = this;
                e.idfield = !1, e.idle = !0;
                let t = e.title;
                e.TABLEWRAPPER && e.TABLEWRAPPER.parentNode.removeChild(e.TABLEWRAPPER);
                let s = e.TABLEWRAPPER = c("", "table-wrapper");
                e.TITLE = h(s, c(t, "itpings-div-title")), e.TABLE = h(s, o("TABLE")), e.THEAD = h(e.TABLE, o("THEAD")), 
                e.TBODY = h(e.TABLE, o("TBODY")), e.innerHTML = '<DIV class="loading">Loading:' + `${t}</DIV>`, 
                this.fetchData();
            }
            fetchData(e = "") {
                let t = this, s = (e, s = "THEAD") => {
                    let i = "THEAD" !== s, n = (i ? t.TBODY : t.THEAD).insertRow(s);
                    T(e).map(s => {
                        let r = i ? e[s] : s;
                        g(n, "data-" + s, r);
                        let l = n.insertCell();
                        ((e, t) => Object.keys(t).map(s => e.setAttribute(s, t[s])))(l, {
                            "data-column": s,
                            ["data-" + s]: r
                        }), f(l, "fadeOutCell"), i && "LastSeen" === s && (r = (e => E(e).diff(E(new Date()), "minutes"))(r)), 
                        s === t.idfield && ~~r > t.maxid && (t.maxid = ~~r), u(l, r);
                    });
                };
                t.idle && (t.idle = !1, C(t.uri + e).then(e => {
                    let i = e.result;
                    if (i) {
                        if (t.idfield) i.length ? (t.TBODY = ((e, t, s) => e.insertBefore(t, s))(t.TABLE, h(t.TABLE, o("TBODY")), t.TBODY), 
                        f(t.TBODY, "newPing"), i.map(e => s(e, 0))) : console.warn("empty result set from:", t.uri); else {
                            let e = i[0], n = T(e)[0];
                            "_" !== n[0] && console.error(n, "might not be a correct Key fieldname return from DBInfo endpoint"), 
                            t.idfield = n, s(e), i.forEach(s), t.innerHTML = "", h(t, t.TABLEWRAPPER), _.register(t);
                        }
                        t.idle = !0;
                    } else {
                        let e = t[M];
                        h(t, c(`<b><a href=?query='${e}'>${e}</a></b>` + " is not a valid ITpings result source", "itpings-table-error"));
                    }
                }).catch(e => {
                    console.error(e), u(t, e + "<h2>Empty Database, check your HTTP Integration setting and reload page</h2>");
                }));
            }
            doPulse(e, t) {
                let s = this, i = s.maxid, r = s.idfield;
                e > i && (n("doPulse Table", s.query, r, t, i, e), this.fetchData("&filter=" + r + " gt " + i));
            }
            attributeChangedCallback(e, t, s) {
                let r = this, l = r.isConnected;
                e === M && (i = s, r.uri = A(s), n("CustomElement attributeChanged:", e + " / " + t + " / " + s, l ? "" : "►► NOT", "Connected"), 
                this.prepareTable());
            }
            connectedCallback() {
                n("CustomeElement connectedCallback");
            }
        });
    }(), function(t = "itpings-chart") {
        let i = (e, i, n, r, l, a, o, d) => s(t, "lightblue", e, i, n, r, l, a, o, d), n = new Map(), r = (e, t, s, i) => n.set(e, {
            interval: t,
            unit: s,
            xformat: i
        });
        r("5m", 5, "MINUTE", "H:mm"), r("30m", 30, "MINUTE", "H:mm"), r("1H", 1, "HOUR", "H:mm"), 
        r("1H", 1, "HOUR", "H:mm"), r("2H", 2, "HOUR", "H:mm"), r("6H", 6, "HOUR", "H:mm"), 
        r("1D", 1, "DAY", "H:mm"), r("2D", 2, "DAY", "D MMM H:mm"), r("7D", 7, "DAY", "D MMM H:mm"), 
        r("2W", 2, "WEEK", "D MMM H:mm"), r("1M", 1, "MONTH", "D MMM"), r("6M", 6, "MONTH", "D MMM"), 
        r("1Y", 1, "YEAR", "D MMM");
        let l = n.get("6H");
        e.customElements.define(t, class extends HTMLElement {
            static get observedAttributes() {
                let e = [ "sensorname", "interval" ];
                return i("CustomElement observedAttributes:", e), e;
            }
            get sensorname() {
                return m(this, "sensorname");
            }
            set sensorname(e) {
                g(this, "sensorname", e);
            }
            get interval() {
                return m(this, "interval");
            }
            set interval(e) {
                i("(setter) ►►►", "interval", ":", e), g(this, "interval", e);
                let t = this, s = t.INTERVALS.querySelector(`[id='${e}']`), r = t.sensorname;
                ((e, t) => localStorage.setItem(e, t))(t.localStorageKey, e), ((e, t, s) => e.map(e => e.classList[e === t ? "add" : "remove"](s)))([ ...this.INTERVALS.children ], s, "selectedInterval");
                let a = t.__INTERVAL = n.has(t.interval) ? n.get(t.interval) : l;
                t.query = "SensorValues", t.sensorids = [], t.ChartJS && t.ChartJS.destroy(), t.ChartJS = new Chart(t.CANVAS, {
                    type: "line",
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        maintainAspectRatio: !1,
                        title: {
                            display: !1,
                            text: ""
                        },
                        showLines: !0,
                        elements: {
                            line: {
                                tension: 0
                            }
                        }
                    }
                }), _.register(t), t.uri = A(t.query + "&sensorname=" + r + "&orderby=created&interval=" + a.interval + "&intervalunit=" + a.unit + "&limit=none&maxrows=225"), 
                this.fetchData();
            }
            fetchData(e = "") {
                let t = this;
                t.TITLE.innerHTML = "Loading:" + t.sensorname, t.idle = !1, C(t.uri + e).then(e => {
                    let s = t.ChartJS.data;
                    i("add_ChartJS_rows", e.result.length, "rows"), e.result.map(e => {
                        t._pingid = e._pingid;
                        let i = t.sensorids.indexOf(e._sensorid);
                        if (i < 0) {
                            i = s.datasets.length;
                            let n = D.getColor(e.dev_id);
                            s.datasets.push({
                                label: (e => [ "", "Node on desk", "Node in attic" ][Number(e.split`_`.reverse()[0])])(e.dev_id),
                                fill: !1,
                                backgroundColor: n,
                                borderColor: n,
                                data: []
                            }), t.sensorids.push(e._sensorid);
                        }
                        let n = E(e.created, t.__INTERVAL.xformat);
                        s.datasets[i].data.push({
                            x: n,
                            y: e.sensorvalue
                        }), s.labels.includes(n) || s.labels.push(n);
                    }), t.ChartJS.update(), this.idle = !0, t.TITLE.innerHTML = t.sensorname;
                });
            }
            doPulse(e) {
                let t = ~~this._pingid;
                t && this.idle ? t < e && (i("doPulse Chart JS _pingid:", t, "new:", e), this.fetchData(`&filter=_pingid%20gt%20${t}`)) : i("►►► No _pingid on Chart JS yet (not drawn yet) ◄◄◄");
            }
            constructor() {
                super();
            }
            attributeChangedCallback(e, t, s) {
                i("attributeChanged:", e, " oldValue:", t, " newValue:", s, " isConnected:", this.isConnected ? "true" : "false");
                let n = this.isConnected;
                switch (i("CustomElement attributeChanged:", e + " / " + t + " / " + s, n ? "" : "►► NOT", "Connected"), 
                e) {
                  case "interval":
                    n && console.error("RELOAD INTERVAL");
                }
            }
            connectedCallback() {
                let e = this, t = e.sensorname;
                e.localStorageKey = t + "_interval", i("CustomeElement connectedCallback");
                let s = c(void 0, "chart-wrapper"), r = e => h(s, e);
                e.TITLE = r(c(t, "itpings-div-title")), e.INTERVALS = [ ...n.keys() ].reduce((t, s) => {
                    return h(t, ((e, t) => {
                        let s = d(e);
                        return g(s, "id", t), s;
                    })(s, s)).addEventListener("click", () => e.interval = s), t;
                }, r(c("", "chart_interval"))), e.CANVAS = r(o("CANVAS")), h(e, s), e.interval = ((e, t) => {
                    let s = localStorage.getItem(e);
                    return s || t;
                })(e.localStorageKey, l);
            }
            disconnectedCallback() {
                i("disconnected", this.isConnected ? "connected" : "NOT connected");
            }
        });
    }();
}(window, document.currentScript.ownerDocument);