/** @license
 * The ITpings Dashboard is minified because I do not want it to go wild without needed refactoring
 * Currently it only works with the default ITpings_configuration.php,
 * many references (eg: '_pingid' are hardcoded in the Dashboard sourcecode
 *
 * The MIT license still applies to this code, feel free to edit the .HTML file anyway you want
 *
 * Be sure to check the Github Repo often for the (future) refactored JS file
 * */
!function(e, t) {
    let i, a = (e, t, i = "", a = "", r = "", l = "", s = "", n = "", o = "", d = "") => {
        console.log(`%cWC:${e}:`, "background:" + t, i, a, r, l, s, n, o, d);
    };
    i = 5e3, console.log("Heartbeat:", i);
    let r = "ttn_node_365csi_nl_001,ttn_node_365csi_nl_002".split`,`;
    let l = new class {
        constructor(e) {
            this.devices = {}, this.colors = "#e6194b,#0082c8,#f58231,#911eb4,#46f0f0,#f032e6,#d2f53c,#fabebe,#008080,#e6beff,#aa6e28,#fffac8,#800000,#aaffc3,#808000,#ffd8b1,#000080,#808080".split(","), 
            this.styles = [ ...t.styleSheets ].filter(t => t.title === e)[0];
        }
        getColor(e) {
            let t, i = this, a = i.devices;
            if (a.hasOwnProperty(e)) t = a[e]; else {
                t = i.colors.shift(), a[e] = t;
                let r = "TD[data-dev_id='" + e + "'] {border-bottom: 3px solid " + t + ";}";
                i.styles.insertRule(r, 0);
            }
            return t;
        }
    }("DynamicDeviceColors");
    r.map(e => l.getColor(e));
    let s = e => t.createElement(e), n = e => {
        let t = s("DIV");
        return e && (t.innerHTML = e), t;
    }, o = (e, t) => e.appendChild(t), d = (e, t) => e.getAttribute(t), c = (e, t, i) => e.setAttribute(t, i), h = (e, t) => e.classList.add(t), u = e => Object.keys(e), m = e => {
        let t = location.href.split`/`;
        return t.pop(), t.push("ITpings_connector.php?query=" + e), t = t.join`/`;
    }, f = "query", p = "pulse";
    let g = e.i = new class {
        _log(e, t, i, r, l, s, n, o) {
            a("IQM", "lightcoral", e, t, i, r, l, s, n, o);
        }
        constructor(t) {
            let a = this;
            a[p] = new Map(), i && (a.interval = e.setInterval(() => {
                a.doPulse();
            }, i));
        }
        register(e) {
            let t, i, a = d(e, p);
            a ? (t = (a = a.split`:`)[0], i = a[1]) : (t = d(e, f), i = e.idfield || "_pingid"), 
            console.log("register", t, i);
            let r = this[p];
            r.has(t) || r.set(t, new Map());
            let l = r.get(t);
            l.has(i) || l.set(i, new Set()), l.get(i).add(e), this._log("register for doPulse", t, i, r);
        }
        doPulse() {
            let e = this;
            fetch(m("IDs")).then(e => e.json()).then(t => {
                e._log("Get recent ID valuesfrom DB, sent Pulse to CustomElements (they decide to fetch New data or not)");
                for (let i in t.maxids) {
                    let a = t.maxids[i], r = u(a)[0], l = a[r], s = e[p].get(i);
                    if (s) {
                        let t = s.get(r);
                        t ? t.forEach(e => e.doPulse(l, r)) : e._log("No fieldSet", i, r, l, s, t);
                    }
                }
            });
        }
    }();
    !function(i = "itpings-table") {
        let r = (e, t, r, l, s, n, o, d) => a(i, "lightgreen", e, t, r, l, s, n, o, d);
        e.customElements.define(i, class extends HTMLElement {
            static get observedAttributes() {
                return [ f, "pulse" ];
            }
            constructor() {
                super(), this.maxid = 1;
            }
            addRow(e, t = "h") {
                let i = this, a = "h" !== t, r = (a ? i.TBODY : i.THEAD).insertRow(t);
                u(e).map(l => {
                    if (!i.hiddenfields.has(l)) {
                        let s = r.insertCell(), n = "h" === t ? l : e[l];
                        if (c(r, "data-" + l, n), ((e, t) => u(t).map(i => c(e, i, t[i])))(s, {
                            ["data-" + l]: n,
                            "data-column": l
                        }), h(s, "fadeOutCell"), a && "LastSeen" === l) {
                            let e = moment(n), t = moment();
                            n = e.diff(t, "minutes");
                        }
                        l === i.idfield && Number(n) > i.maxid && (i.maxid = Number(n)), s.innerHTML = n;
                    }
                });
            }
            fetchData(e) {
                let t = this, i = t.addRow.bind(t);
                t.idle && (t.idle = !1, r("filter:", e), fetch(t.uri + e).then(e => e.json()).then(e => {
                    let a = e.result;
                    if (a) {
                        if (t.idfield) a.length && (t.TBODY = ((e, t, i) => e.insertBefore(t, i))(t.TABLE, o(t.TABLE, (() => s("TBODY"))()), t.TBODY), 
                        h(t.TBODY, "newPing"), a.map(e => i(e, 0))); else {
                            let e = a[0];
                            i(e), t.idfield = u(e)[0], console.log("reg", t.idfield, t), a.map(i), o(t, t.TABLEWRAPPER), 
                            g.register(t);
                        }
                        t.idle = !0;
                    } else {
                        let e = t[f], i = n(`<b><a href=?query='${e}'>${e}</a></b>` + " is not a valid ITpings result source");
                        h(i, "itpings-table-error"), o(t, i);
                    }
                }).catch(e => {
                    console.error(e), t.innerHTML = e;
                }));
            }
            doPulse(e, t) {
                let i = this, a = i.maxid, l = i.idfield;
                e > a && (r("doPulse Table", i.query, l, t, a, e), i.fetchData("&filter=" + l + " gt " + a));
            }
            attributeChangedCallback(e, t, i) {
                let a = this;
                a[e] = i, e === f ? (a.uri = m(i), a.filter = "", a.idle = !0) : "pulse" === e && (r("do pulse from", e, t, i, a.query), 
                a.isPulsed = !0, a.doPulse());
            }
            connectedCallback() {
                let e = this;
                e.TABLEWRAPPER = n(), e.TABLE = o((() => t.createDocumentFragment())(), (() => s("TABLE"))());
                let i = t => o(e.TABLE, s(t));
                e.THEAD = i("THEAD"), e.TBODY = i("TBODY");
                let a = o(e.TABLEWRAPPER, n());
                a.innerHTML = e.title, h(a, "table-title"), o(e.TABLEWRAPPER, e.TABLE), h(e.TABLEWRAPPER, "table-wrapper"), 
                e.hiddenfields = new Set([ "timestamp", "created" ]), e.fetchData("");
            }
        });
    }(), function(t = "itpings-chart") {
        let i = (e, i, r, l, s, n, o, d) => a(t, "lightblue", e, i, r, l, s, n, o, d), r = {
            m5: {
                interval: 5,
                unit: "MINUTE",
                xformat: "H:mm"
            },
            m03: {
                interval: 30,
                unit: "MINUTE",
                xformat: "H:mm"
            },
            H1: {
                interval: 1,
                unit: "HOUR",
                xformat: "H:mm"
            },
            H2: {
                interval: 2,
                unit: "HOUR",
                xformat: "H:mm"
            },
            H6: {
                interval: 6,
                unit: "HOUR",
                xformat: "H:mm"
            },
            D1: {
                interval: 1,
                unit: "DAY",
                xformat: "D MMM H:mm"
            },
            D2: {
                interval: 2,
                unit: "DAY",
                xformat: "D MMM H:mm"
            },
            W2: {
                interval: 2,
                unit: "WEEK",
                xformat: "D MMM H:mm"
            },
            M1: {
                interval: 1,
                unit: "MONTH",
                xformat: "D MMM"
            },
            M6: {
                interval: 6,
                unit: "MONTH",
                xformat: "D MMM"
            },
            Y1: {
                interval: 1,
                unit: "YEAR",
                xformat: "D MMM"
            }
        };
        e.customElements.define(t, class extends HTMLElement {
            static get observedAttributes() {
                let e = [ "sensorname", "interval" ];
                return i("CustomElement observedAttributes", e), e;
            }
            get chartid() {
                return d(this, "chartid");
            }
            get sensorname() {
                return d(this, "sensorname");
            }
            set sensorname(e) {
                c(this, "sensorname", e);
            }
            get interval() {
                return d(this, "interval");
            }
            set interval(e) {
                i("(setter) ►►►", "interval", ":", e);
                let t = this.INTERVALS.querySelector("[id='" + e + "']");
                localStorage.setItem(this.chartid + "_interval", e), [ ...this.INTERVALS.children ].map(e => e.classList[e === t ? "add" : "remove"]("selectedInterval")), 
                c(this, "interval", e), this.prepareChart(!1);
            }
            prepareChart(e = !1) {
                let t = this, a = t.sensorname;
                e && (t.interval = e);
                let l = t.interval, s = r[l];
                s || (s = r.H6), i("prepareChart _interval", l, s, e ? "localStorage" : ""), t._interval = s, 
                t.ChartJS = {
                    id: a,
                    uri: m("SensorValues&sensorname=" + a + "&orderby=created&interval=" + s.interval + "&intervalunit=" + s.unit + "&limit=none&maxrows=225"),
                    chartdata: {
                        labels: [],
                        datasets: [],
                        sensorids: []
                    }
                }, t.chart && t.chart.destroy(), t.chart = new Chart(t.CANVAS, {
                    type: "line",
                    data: [],
                    options: {
                        maintainAspectRatio: !1,
                        title: {
                            display: !0,
                            text: a
                        },
                        showLines: !0,
                        elements: {
                            line: {
                                tension: 0
                            }
                        }
                    }
                }), t.displayChart(t.ChartJS.uri);
            }
            doPulse(e) {
                let t = this, a = ~~t._pingid;
                if (a) {
                    if (a < e) {
                        i("doPulse ChartJS _pingid:", a, "new:", e);
                        let r = t.chart, l = m("SensorValues&sensorname=" + t.ChartJS.id + "&orderby=_pingid%20ASC&limit=none&filter=_pingid%20gt%20" + a);
                        fetch(l).then(e => e.json()).then(e => {
                            let a = t.ChartJS.chartdata, l = e.result;
                            i("updateChart", l.length, "rows from:", e.sql), l.map(e => {
                                let i = e._sensorid, r = e.sensorvalue, l = a.sensorids.indexOf(i), s = e.created;
                                s = moment(s).format(t._interval.xformat), t._pingid = e._pingid, a.datasets[l].data.push({
                                    x: s,
                                    y: r
                                }), a.labels.includes(s) || a.labels.push(s);
                            }), r.update();
                        });
                    }
                } else i("►►► No _pingid on ChartJS yet (not drawn yet) ◄◄◄");
            }
            updateChart(e) {}
            displayChart(e) {
                let t = this, a = t.chart;
                fetch(e).then(e => e.json()).then(e => {
                    let r = t.ChartJS.chartdata, s = e.result, n = "";
                    i("displayChart", s.length, "rows"), r = s.reduce(function(e, i, a) {
                        t._pingid = i._pingid;
                        let r = i.dev_id, s = i._sensorid, o = i.sensorvalue, d = e.sensorids.indexOf(s), c = i.created;
                        if (c = moment(c).format(t._interval.xformat), n = i.sensorname, d < 0) {
                            d = e.datasets.length;
                            let t = l.getColor(r);
                            e.datasets.push({
                                label: (e => [ "", "attic", "desk" ][Number(e.split`_`.reverse()[0])])(r),
                                fill: !1,
                                backgroundColor: t,
                                borderColor: t,
                                data: []
                            }), e.sensorids.push(s);
                        }
                        return e.datasets[d].data.push({
                            x: c,
                            y: o
                        }), e.labels.includes(c) || e.labels.push(c), e;
                    }, r), a.data.labels = r.labels, a.data.datasets = r.datasets, a.update();
                });
            }
            constructor() {
                super();
            }
            attributeChangedCallback(e, t, a) {
                let r = this;
                switch (i("attributeChanged:", e, " oldValue:", t, " newValue:", a, " isConnected:", r.isConnected ? "true" : "false"), 
                e) {
                  case "interval":
                    r.isConnected;
                }
            }
            connectedCallback() {
                let e = this;
                i("CustomElement connectedCallback");
                let t = n(), a = e => o(t, s(e));
                (e => h(t, e))("chart"), c(t, "style", "position:relative;height:inherit;"), e.CANVAS = a("CANVAS");
                let l = e.INTERVALS = a("DIV"), d = t => o(l, (t => {
                    let i = n((e => [ ...e ].reverse().join``)(t));
                    return c(i, "id", t), i.addEventListener("click", () => e.interval = t), i;
                })(t));
                u(r).map(e => d(e)), h(l, "chart_interval"), o(e, t);
                let m = e.chartid, f = !1;
                m ? (f = localStorage.getItem(m + "_interval"), i("localStorage:", m, f), e.interval = f || e.interval) : console.error("no id on chart", e), 
                g.register(e);
            }
            disconnectedCallback() {
                i("disconnected", this.isConnected ? "connected" : "NOT connected");
            }
        });
    }();
}(window, document.currentScript.ownerDocument);