/** @license MIT
 * This Dashboard uses hardcoded Databases references
 * If you make changes in the Database Schema, be sure to check those new names in this Dashboard source code
 * */
!function(e, t) {
    let i = (e, t = "lightcoral", i = "", l = "", r = "", n = "", s = "", a = "", o = "", d = "") => {
        console.log(`%cWC:${e}:`, "background:" + t, i, l, r, n, s, a, o, d);
    };
    const l = "_pingid", r = "frequency,snr,rssi,channel".split`,`, n = " QueryManager can't register", s = "register for do Pulse";
    let a = e => void 0 !== e, o = e => e.split`,`, d = e => e.shift(), c = e => t.createElement(e), u = (e, t = c("DIV")) => (e && (t.innerHTML = e), 
    t), m = (e, t, i = u(e)) => (i.classList.add(t), i), h = (e, t = "") => e.innerHTML = t, f = (e, t) => e.appendChild(t), g = (e, t) => e.getAttribute(t), p = (e, t, i) => e.setAttribute(t, i), T = (e, t) => e.classList.add(t), E = e => Object.keys(e), C = (e, t) => a(t) ? moment(e).format(t) : moment(e), b = e => new Promise((t, l) => {
        fetch(e).then(e => e.json()).then(l => {
            l.hasOwnProperty("result") && i("Fetched", "orange", l.result.length, "rows from:", e), 
            t(l);
        });
    }), D = e => {
        let t = location.href.split`/`;
        return t.pop(), t.push("ITpings_connector.php?query=" + e), t = t.join`/`;
    }, A = e => `<DIV class="loading">Loading: ${e}</DIV>`;
    let v = new class {
        constructor(e) {
            this.STYLE = [ ...t.styleSheets ].find(t => t.ownerNode.id === e), this.deviceColor = new Map(), 
            this.colors = o("#e6194b,#0082c8,#f58231,#911eb4,#46f0f0,#f032e6,#d2f53c,#fabebe,#008080,#e6beff,#aa6e28,#fffac8,#800000,#aaffc3,#808000,#ffd8b1,#000080,#808080,#ffe119");
        }
        getColor(e) {
            let t, i = this;
            if (i.deviceColor.has(e)) t = i.deviceColor.get(e); else {
                t = d(i.colors), i.deviceColor.set(e, t);
                let l = `span[data-dev_id='${e}']::before{background:${t}}`;
                i.STYLE.insertRule(l, 0);
            }
            return t;
        }
    }("DynamicDeviceColors"), y = "PingID", S = "IDs", L = "query", H = "pulse";
    class M {
        static _log() {
            i("IQM", "lightcoral", ...arguments);
        }
        constructor() {
            this.maxid = 0, this[H] = new Map(), this.doPulse(y);
        }
        register(e) {
            let t, i, r = g(e, H);
            r ? (t = (r = r.split`:`)[0], i = r[1]) : (t = e.query || g(e, L), i = e.idfield || l), 
            t || console.error(n, e);
            let a = this[H];
            a.has(t) || a.set(t, new Map());
            let o = a.get(t);
            o.has(i) || o.set(i, new Set()), o.get(i).add(e), M._log(s, t, i);
        }
        doPulse(t) {
            let i = this, l = (t, l) => e.setTimeout(() => i.doPulse(t), l || I);
            b(D(t)).then(e => {
                t === y ? e > i.maxid ? (i.maxid = e, l(S, 1)) : l(y) : (M._log("heartbeat:", I, "Got recent ID values from Database", e), 
                E(e.maxids).forEach(t => {
                    let l = e.maxids[t], r = E(l)[0], n = l[r], s = i[H].get(t);
                    if (s) {
                        let e = s.get(r);
                        e ? e.forEach(e => e.doPulse(n, r)) : M._log("No fieldSet", t, r, n, s, e);
                    }
                }), l(y));
            });
        }
    }
    let I, _ = e.i = new M(), w = e => {
        i("Heartbeat:", "orange", I = e), a(_) && _.doPulse(y);
    };
    w(1e3), e.onfocus = (() => w(1e3)), e.onblur = (() => w(18e5)), function(l = "itpings-table") {
        let r, n = (e, t, n, s, a, o, d, c, u) => i(l + ":" + r, "lightgreen", e, t, n, s, a, o, d, c, u);
        e.customElements.define(l, class extends HTMLElement {
            static get observedAttributes() {
                let e = [ L ];
                return n("CustomElement observedAttributes:", e), e;
            }
            get title() {
                return g(this, "title");
            }
            set title(e) {
                p(this, "title", e);
            }
            constructor() {
                super(), r = this.getAttribute(L), n("CustomElement constructor", this), this.maxid = 1;
            }
            fetchData(e = "") {
                let i = this;
                i.requiredColumns = new Set();
                let l = (e, t = "THEAD") => {
                    let l = "THEAD" !== t, r = (l ? i.TBODY : i.THEAD).insertRow(t);
                    return E(e).map(t => {
                        let n = l ? e[t] : t;
                        p(r, "data-" + t, n);
                        let s = r.insertCell();
                        ((e, t) => Object.keys(t).map(i => e.setAttribute(i, t[i])))(s, {
                            "data-column": t,
                            ["data-" + t]: n
                        }), T(s, "fadeOutCell");
                        let a = (e, r) => {
                            l && t === e && n !== r && i.requiredColumns.add(t);
                        };
                        return a("modulation", "LORA"), a("coding_rate", "4/5"), a("data_rate", "SF7BW125"), 
                        l && "LastSeen" === t && (n = (e => C(e).diff(C(new Date()), "minutes"))(n)), l && "dev_id" === t && (n = `<SPAN data-column="${t}" data-${t}="${n}">${n}</SPAN>`), 
                        l && t === i.idfield && ~~n > i.maxid && (i.maxid = ~~n), h(s, n), {
                            name: t,
                            value: n,
                            TR: r,
                            TD: s
                        };
                    });
                };
                i.idle && (i.idle = !1, b(i.uri + e).then(e => {
                    let r = e.result;
                    if (r) {
                        if (i.idfield) if (r.length) {
                            i.TBODY = ((e, t, i) => e.insertBefore(t, i))(i.TABLE, f(i.TABLE, c("TBODY")), i.TBODY), 
                            T(i.TBODY, "newPing");
                            let e = r.map(e => l(e, 0));
                            n(i.query, 22, e);
                        } else console.warn("empty result set from:", i.uri); else {
                            let e = r[0], t = E(e)[0];
                            "_" !== t[0] && console.error(t, "might not be a correct Key fieldname return from DBInfo endpoint"), 
                            i.idfield = t, l(e), i.columns = new Set(r.forEach(l)), h(i), f(i, i.WRAPDIV), _.register(i);
                        }
                        i.idle = !0;
                    } else {
                        let e = i[L];
                        f(i, m(`<b><a href=?query='${e}'>${e}</a></b>` + " is not a valid ITpings result source", "itpings-table-error"));
                    }
                    i.requiredColumns.forEach(e => ((e, i, l = t.body) => l.style.setProperty(e, i))("--CSSdisplay_" + e, "table-cell", i.TABLE));
                }).catch(e => {
                    console.error(e);
                }));
            }
            doPulse(e, t) {
                let i = this, l = i.maxid, r = i.idfield;
                e > l && (n(i.query, "idfield:", r, "pulseidfield:", t, "maxid:", l, "_pingid:", e), 
                this.fetchData("&filter=" + r + " gt " + l));
            }
            attributeChangedCallback(e, t, i) {
                let l = this, s = l.isConnected;
                if (e === L) {
                    r = i, l.uri = D(i), n("CustomElement attributeChanged:", e + " / " + t + " / " + i, s ? "" : "►► NOT", "Connected"), 
                    l.idfield = !1, l.idle = !0;
                    let a = l.title;
                    l.WRAPDIV && l.WRAPDIV.parentNode.removeChild(l.WRAPDIV);
                    let o = l.WRAPDIV = m("", "table-wrapper");
                    l.HEADER = f(o, c("TABLE")), T(l.HEADER, "sticky-header"), l.TITLE = f(l.HEADER, c("CAPTION")), 
                    T(l.TITLE, "itpings-div-title"), l.TITLE.innerHTML = a, l.THEAD = f(l.HEADER, c("THEAD")), 
                    l.TABLE = f(o, c("TABLE")), T(l.TABLE, "data-table"), l.TBODY = f(l.TABLE, c("TBODY")), 
                    h(l, A(a)), this.fetchData();
                }
            }
            connectedCallback() {
                n("CustomeElement connectedCallback");
            }
        });
    }(), function(t = "itpings-chart") {
        let n = (e, l, r, n, s, a, o, d, c) => i(t, "lightblue", e, l, r, n, s, a, o, d, c), s = new Map(), a = (e, t, i, l) => s.set(e, {
            interval: t,
            unit: i,
            xformat: l
        });
        a("5m", 5, "MINUTE", "H:mm"), a("30m", 30, "MINUTE", "H:mm"), a("1H", 1, "HOUR", "H:mm"), 
        a("1H", 1, "HOUR", "H:mm"), a("2H", 2, "HOUR", "H:mm"), a("6H", 6, "HOUR", "H:mm"), 
        a("1D", 1, "DAY", "H:mm"), a("2D", 2, "DAY", "D MMM H:mm"), a("7D", 7, "DAY", "D MMM H:mm"), 
        a("2W", 2, "WEEK", "D MMM H:mm"), a("1M", 1, "MONTH", "D MMM"), a("6M", 6, "MONTH", "D MMM"), 
        a("1Y", 1, "YEAR", "D MMM");
        let o = s.get("6H");
        e.customElements.define(t, class extends HTMLElement {
            static get observedAttributes() {
                let e = [ "sensorname", "interval" ];
                return n("CustomElement observedAttributes:", e), e;
            }
            get title() {
                return g(this, "title");
            }
            set title(e) {
                p(this, "title", e);
            }
            get sensorname() {
                return g(this, "sensorname");
            }
            set sensorname(e) {
                p(this, "sensorname", e);
            }
            get interval() {
                return g(this, "interval");
            }
            set interval(e) {
                n("(setter) ►►►", "interval", ":", e), p(this, "interval", e);
                let t = this;
                t.idle = !1;
                let i = t.INTERVALS.querySelector(`[id='${e}']`), l = t.sensorname;
                ((e, t) => localStorage.setItem(e, t))(t.localStorageKey, e), ((e, t, i) => e.map(e => e.classList[e === t ? "add" : "remove"](i)))([ ...this.INTERVALS.children ], i, "selectedInterval");
                let a = t.__INTERVAL = s.has(t.interval) ? s.get(t.interval) : o;
                r.includes(l) ? (t.query = "PingedDevices", t.uri = D(t.query), t.value_field_name = l) : (t.query = "SensorValues", 
                t.uri = D(t.query + "&sensorname=" + l), t.value_field_name = "sensorvalue"), t.uri += "&orderby=created&interval=" + a.interval, 
                t.uri += "&intervalunit=" + a.unit + "&limit=none&maxrows=100", t.ChartJS_Lines = [], 
                t.ChartJS && t.ChartJS.destroy(), t.ChartJS = new Chart(t.CANVAS, {
                    type: "line",
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        maintainAspectRatio: !1,
                        title: {
                            display: !1,
                            text: ""
                        },
                        tooltips: {
                            mode: "index",
                            intersect: !1
                        },
                        hover: {
                            mode: "nearest",
                            intersect: !0
                        },
                        legend: !1,
                        showLines: !0,
                        elements: {
                            line: {
                                tension: 0
                            }
                        }
                    }
                }), _.register(t), this.fetchData();
            }
            fetchData(e = "") {
                let t = this;
                h(t.TITLE, A(t.title || t.sensorname)), t.idle = !1, t.INTERVALS.style.display = "none", 
                b(t.uri + e).then(e => {
                    let i = e.result, r = t.ChartJS.data, n = t.ChartJS.data.datasets;
                    null !== i[0] && (i.map(e => {
                        t[l] = e[l];
                        let i = C(e.created, t.__INTERVAL.xformat);
                        if (!r.labels.includes(i)) {
                            r.labels.push(i);
                            let l = e.dev_id, s = t.ChartJS_Lines.indexOf(l);
                            if (s < 0) {
                                s = n.length;
                                let e = v.getColor(l);
                                n.push({
                                    label: (e => e)(l),
                                    fill: !1,
                                    backgroundColor: e,
                                    borderColor: e,
                                    data: []
                                }), t.ChartJS_Lines.push(l);
                            }
                            n[s].data.push({
                                x: i,
                                y: e[t.value_field_name]
                            });
                        }
                    }), t.ChartJS.update()), this.idle = !0, t.INTERVALS.style.display = "initial", 
                    h(t.TITLE, t.title || t.sensorname);
                });
            }
            doPulse(e) {
                let t = ~~this[l];
                t && this.idle ? t < e && (n("doPulse Chart JS current_ping_id:", t, "new:", e), 
                this.fetchData(`&filter=${l}%20gt%20${t}`)) : n("►►► No pingid on Chart JS yet (not drawn yet) ◄◄◄");
            }
            constructor() {
                super();
            }
            attributeChangedCallback(e, t, i) {
                let l = this.isConnected;
                switch (e) {
                  case "interval":
                    l && n("CustomElement attributeChanged:", e + " / " + t + " / " + i, l ? "" : "►► NOT", "Connected");
                }
            }
            connectedCallback() {
                let e = this, t = e.sensorname;
                e.localStorageKey = t + "_interval", n("CustomeElement connectedCallback");
                let i = m(void 0, "chart-wrapper"), l = e => f(i, e);
                e.TITLE = l(m(t, "itpings-div-title")), e.INTERVALS = [ ...s.keys() ].reduce((t, i) => {
                    return f(t, ((e, t, i = u(e)) => (p(i, "id", t), i))(i, i)).addEventListener("click", () => e.interval = i), 
                    t;
                }, l(m("", "chart_interval"))), e.CANVAS = l(c("CANVAS")), f(e, i), e.interval = ((e, t, i = localStorage.getItem(e)) => i || t)(e.localStorageKey, o);
            }
            disconnectedCallback() {
                n("disconnected", this.isConnected ? "connected" : "NOT connected");
            }
        });
    }();
}(window, document.currentScript.ownerDocument);